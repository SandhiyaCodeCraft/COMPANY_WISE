2025:
1.string tank
def find_tank(water):
    total_water = sum([float(x) for x in water])
    left_sum = 0
    for i in range(len(water)):
        right_sum = total_water - left_sum - float(water[i])
        if left_sum == right_sum:
            return i  
        left_sum += float(water[i])
    return -1  

water = ["0.6", "0.7", "0.3", "0.4", "0.9"]
result = find_tank(water)
print(f"Tank at index {result} satisfies the condition")

2.MAZE QN
def find_unreachable_or_loop(A, S):
    visited = set()
    index = S
    direction = 1  # Start by moving right

    while True:
        if index in visited:
            return -1  # Loop detected

        visited.add(index)
        steps = A[index]
        next_index = index + direction * steps

        if next_index < 0 or next_index >= len(A):
            return A[index]  # Return current value before move

        index = next_index
        direction *= -1  # Alternate direction


1.
l=int(input("Enter the litres to fill the tank:"))
d=int(input("Enter the distance covered:"))
fuel = (l/d)*100
print(f"{fuel:.2f}litres/100KM")
miles=d*0.6214
gallon=l*0.2642
m_g=miles/gallon
print(f"miles/gallon{m_g:.2f}")

2.
n1=int(input("Enter no of pizzas:"))
n2=int(input("Enter no of puffs:"))
n3=int(input("Enter no of drinks:"))
tp=n1*100
tpu=n2*20
td=n3*10
s=tp+tpu+td
print("Total price =",s)

3.
n=int(input())
s=str(n)
l=[s[i:i+2] for i in range(0,len(s),2)]
for i in l:
    print(i,"-",chr(int(i)))

5.
import sys..................................EFFICIENT FOR EXIT 
def total(T,P,R,Co):
    sum_total=0
    base_price=T*P....................giving discount on ticket price not on whole price(not including snacks)
    if R=='y':
        sum_total+=T*50
    sum_total+=base_price
    if T>20:
        if Co=='y':
            d_t=(10/100)*base_price
            base_price-=d_t//uppdate 
            d_r=(2/100)*base_price
            discount=d_t+d_r
        else:
            discount=(10/100)*base_price
    else:
        if Co=='y':
            discount=(2/100)*base_price
        else:
            discount=0
    return sum_total-discount
    
t=int(input("Enter number of tickets:"))
if(t<5 or t>40):
    print("Minimum of 5 and Maximum of 40 tickets")
    sys.exit()
else:
    k_p=75
    q_p=150
    r=input("Do you want refreshments(y/n):").lower()
    c=input("Do you have coupon code(y/n):").lower()
    C=input("Enter the Circle(k/q):").lower()
    if C=='k':
        res=total(t,k_p,r,c)
        print(f"{res:.2f}")
    elif C=='q':
        res=total(t,q_p,r,c)
        print(f"{res:.2f}")
    else:
        print("Invalid input")
        sys.exit()
6.
n=int(input("Enter the month:"))
if n==12 or n==1 or n==2:
    print("season:winter")
elif n>=3 and n<=5:
    print("Season:spring")
elif n>=6 and n<=8:
    print("Season:summer")
elif n>=9 and n<=11:
    print("Season:Autumn")

7,8 simple
9.def increment(r,s):
    if r>=1 and r<=3:
        inc=(10/100)*s
    elif r>3 and r<=4:
        inc=(25/100)*s
    elif r>4 and r<=5:
        inc=(30/100)*s
    else:
        inc=0
    return inc
s=float(input())
r=float(input())
if s<=0 or (r<=0 or r>5):
    print("invalid input")
else:
    res=increment(r,s)
    print(s+res)

10.
n=int(input())
S=list(str(n))
s=sum([int(i) for i in S])
if s%3==0 or s%5==0 or s%7==0:
    print("lucky number")
else:
    print("invalid")

12.
n=int(input())
res=float('inf')
it=''
for i in range(n):
    val=input().split(',')
    item=val[0]
    price=int(val[1])
    dis=int(val[2])
    discount=(price*dis)//100
    if discount<res:
        res=discount
        it=item
print(it)

15........................given array is price for each day....initialy 0.....summing price since first day..
eg:in the loop 4th day price is calculated by adding prices from first day....then only we can calculate todsay price is low or not.
n = int(input())
changes = list(map(int, input().split()))
price = 0
min_price = 0 
for c in changes:
    price += c
    min_price = min(min_price, price)
print(min_price)

17.X...means a person we want to find his siblings.........
def find_siblings(N, arr, X):
    if X not in arr:
        return [-1] 
    index = arr.index(X)
    if index == 0:.................0 th indexis root person there is no sibling ...only child
        return [-1]
    
    parent = (index - 1) // 2..........parent index
    siblings = []
    
    left = 2 * parent + 1...........using parent index find the childs
    right = 2 * parent + 2
    if left < N and arr[left] != X:.............append the child except x
        siblings.append(arr[left])
    if right < N and arr[right] != X:
        siblings.append(arr[right])
    if not siblings:
        return [-1]............no sibling means return -1
    return sorted(siblings)

print(find_siblings(5, [1,2,3,4,5], 1))  
print(find_siblings(5, [1,2,3,4,5], 2)) 
print(find_siblings(5, [1,2,3,4,5], 4)) 

19.
def mod11(num_str):
    remainder = 0
    for digit in num_str:
        remainder = (remainder * 10 + int(digit)) % 11
    return remainder

# Example
num_str = "13589234356546756"
print(mod11(num_str))  # Output: 6


20.....o(N^2) this approach....if arr not sorted ...sort it......she start from anywhere and end anywhere
n=int(input())
l=list(map(int,input().split()))
maxb=0
for i in range(len(l)):
    sub=[]
    for j in range(i,len(l)):
        sub.append(l[j])
        res=min(sub).........y min is ...now only she take eq bulbs from the consecutive machines
        maxb=max(maxb,res)
print(maxb)

o(N)...................max(l)

21.
rows = int(input())
cols = int(input())
arr = list(map(int, input().split()))
mat=[]
for i in range(rows):............................creating matrix using arr
    mat.append(arr[i*cols : (i+1)*cols])
rs=[sum(i) for i in mat]
cs=[]
for j in range(cols):
    sc=0
    for i in range(rows):
        sc+=mat[i][j]
    cs.append(sc)
print(max(rs)+max(cs))

22.
.......................this code works for n<=20......small numbers only
def cal(n,r,m):
    def fact(n):
        fact=1
        for i in range(1,n+1):
            fact*=i
        return fact
    nf=fact(n)
    rf=fact(r)
    nrf=fact(n-r)
    res=nf//(rf*nrf)
    return res%m
n=int(input())
r=int(input())
m=int(input())
print(cal(n,r,m))

23.
def derangement(n):
    if n == 0:
        return 1
    if n == 1:
        return 0

    prev2 = 1  # !0
    prev1 = 0  # !1

    for i in range(2, n+1):
        current = (i-1) * (prev1 + prev2)
        prev2 = prev1
        prev1 = current

    return prev1

n = 3
print(derangement(n))  # Output: 2

24.
  words = sentence.split()
    cnt = 0
    for w in words:
        if not w:
            continue
        k = N % len(w)
        rotated = w[-k:] + w[:-k]   # right rotation by k
        if rotated == w:
            cnt += 1
    return cnt

26
nums = [1, 1, 4, 2, 3], x = 5 o/p:2..............................from the last 5-3=2...2-2=0 so ans:2..............logic is ...find the value res=sum(l)-x=6...
then find the longest subarray of sum =6 ...find the max length of subarr of sum=6...and return the ans by print(len(l)-m)....m is length of long sub with sum=6

l=list(map(int,input().split()))
x=int(input())
res=sum(l)-x
m=0
for i in range(len(l)):
    sub=[]
    for j in range(i,len(l)):
        sub.append(l[j])
        if sum(sub)==res:
            m=max(m,len(sub))
if m==0:
    print('-1')
else:
    print(len(l)-m)

27.
dic = {}
l = 0
ml = 0

for r in range(len(s)):
    c = s[r]
    if c in dic and dic[c] >= l:
        l = dic[c] + 1
    dic[c] = r
    ml = max(ml, r - l + 1)

return ml

29.container with most
   l=0
        r=len(height)-1
        max_water=0
        while l<r:
            w=(r-l)
            h=min(height[l],height[r])
            cm=w*h
            max_water=max(max_water,cm)
            if height[l]<height[r]:
                l+=1
            else:
                r-=1
        return max_water

28.
flat_list = [num for row in matrix for num in row]
    flat_list.sort()
    return flat_list[k-1]

VIDEOS:
1.Return the count if left + right = that element in array

li=[1,2,1,3,5,2,4,2,3,1]
c=0
for i in range(1,len(li)-1):
    l=i-1
    r=i+1
    if li[i]==li[l]+li[r]:
        c+=1
print(c).....................o/p:4

2. 1
  2 1 2
 3 2 1 2 3

n = int(input("Enter pyramid height: "))
total_sum = 0
for i in range(1, n + 1):
    row = list(range(i, 0, -1)) + list(range(2, i + 1))  # e.g., 3 2 1 2 3
    total_sum += sum(row)
print("Sum:", total_sum)

3.You are playing a game and want to cross as many levels as possible in the game. To advance from one level to another, these are the rules:
A player has an initial energy N.From level i, you have to spend the highest power of 2, i.e., X, from the current level in order to go to the next level.
The value of X is then concatenated to the score for each level you cross.Your task is to find and return an integer value representing the final concatenated score by crossing the maximum possible levels with the given initial energy.

import math

def highlevel(n):
    if n == 0:
        return ""
    
    max_pow = 2 ** int(math.log(n,2))  # Find the highest power of 2 ≤ n................if want highest pow of 3......use 3**int(math.log(n,3))
    return str(max_pow) + highlevel(n - max_pow)

n = int(input())
print(highlevel(n))

4.ANAGRAM OR NOT
optimised code:
def anagram(S1,S2):
    if len(S1)!=len(S2):
        return False
    d={}
    for i in S1:
        d[i] = d.get(i,0)+1
    for i in S2:
        if i not in d or d[i]==0:
            return False
        d[i]-=1 //means all letters should be there ,should not be zero
    return True
s1 = "liste"
s2 = "silent"
S1 = s1.replace(" ","").lower()
S2 = s2.replace(" ","").lower()
print(anagram(S1,S2))

5.Palindrome

S=input()
s=list(S)
l=0
r=len(s)-1
while l<r:
    s[l],s[r]=s[r],s[l]
    l+=1
    r-=1
print(S==''.join(s))

6.Missing number

class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        n=len(nums)
        s=sum(nums)
        t=n*(n+1)/2
        return int(t-s)
7.MERGE TWO SORTED ARRAYS
8.Kth LARGEST ELEMENT ARRAY 
8.MAX SUM IN CONTIGUOUS ARRAY:
n=int(input())
l=list(map(int,input().split()))
m=-1
for i in range(len(l)):
    sub=[]
    for j in range(i,len(l)):
        sub.append(l[j])
        res=sum(sub)
        m=max(m,res)
print(m)

8.Duplicates in array
n=int(input())
l=list(map(int,input().split()))
d={}
for i in l:
    d[i]=d.get(i,0)+1
res= [i for i,j in d.items() if j>1]
print(*res)

9.pen change prob:odd:green,even:red......return switch count
i/p: 72 23 13 26 72 19
o/p:3

n = int(input())
l = list(map(int, input().split()))
s = 0
for i in range(n - 1):
    if (l[i] % 2) != (l[i + 1] % 2):  # parity change
        s += 1
print(s)

10.MAGICAL ROW ---ROW SUM IS EVEN

n=int(input())
m=int(input())
l=[]
for i in range(n):
    s=list(map(int,input().split()))
    l.append(s)
magical=0
for i in range(n):
    oddsum=0
    for j in range(m):
        if (l[i][j])%2!=0:
           oddsum+=l[i][j]
    if oddsum%2==0:
        magical+=1
print(magical)

o/p:n=3,m=3
    l=[[1,2,3],[4,5,6],[7,8,9]]
    o/p:2

11.You have a sorted box of numbers stored in an integer array A and you want to find all the "mini boxes" (subarrays) that meet a special rule. 
This rule says that the sum of the smallest and biggest number in each mini box must be less than or equal to a given number X Remember,
the original box is already sorted, so the smallest number is always at the beginning, and the biggest one is at the end of each mini box you create.
Your task is to find and return an integer value representing the number of mini boxes that can be made which follow the rule.

x=int(input())
arr=list(map(int,input().split()))
c=0
for i in range(len(arr)):
    sub=[]
    for j in range(i,len(arr)):
        sub.append(arr[j])
        l=min(sub)
        h=max(sub)
        if l+h <= x:
            c+=1
print(c)

o/p:x=5
    1 3 5 8
    o/p:2

12.Smart Shopping

You are given an array of N elements representing the prices of each item You are alsos given a discount offer that allows you to buy K items at a reduced price. 
The discount offer works as, for every most expensive K items you decide to buy, the cost of tise maximum priced item out of those K items will be waived
Your task is to find and return an integer value representing the total cost after comapplying the maximum discount offer.

inputl: 5
input2: 3
input3: 5,7,10,3,2
Output: 12

Explanation:

Here, the given price array is (5,7,10,3,2) and the value of K = 3. Therefore, we can buy 3 most expensive items to get maximum discount.
So, we take the items with prices 10+ 7 + 5 = 22. The total cost achievable using the given maximum discount offer is 22-10 12.
Therefore. 12 is returned as the output.

n=int(input())
k=int(input())
arr=list(map(int,input().split()))
arr.sort(reverse=True)
dis=max(arr)
s=0
for i in range(k):
    s+=arr[i]
print("Discounted price:",s-dis)

13.rhythms, Blue Bandit wants the list of prime numbers available in a range of numbers.Can you help him out?
prime numbers in the interval [a,b] (a and b, both Write a java program to print all prime › print all p inclusiv
Input 1 should be lesser than Input 2.Both the inputs should be positive.Range must always be greater than zero.
If any of the condition mentioned above fails, then display "Provide valid input"

import math
def prime(n):
    if n<=1:
        return False
    for i in range(2,int(math.sqrt(n))+1):
        if n%i==0:
            return False
    return True
a=int(input())
b=int(input())
if a>0 and b>0 and a<b:
    for i in range(a,b+1):
        if prime(i)==True:
            print(i,end=" ")
else:
    print("provide valid input")

i/p:2
    15
o/p: 2 3 5 7 11 13

14.Reverse pyramid star pattern
n=int(input())
for i in range(n):
    for j in range(i+1):
        print(" ",end=" ")
    for j in range(i,n):
        print("*",end=" ")
    for j in range(i,n-1):
        print("*",end=" ")
    print()

15.FIND TOTAL
pi=int(input("Enter no of pizzas bought:"))
pu=int(input("Enter no of puffs bought:"))
co=int(input("Enter no of cooldrinks bought:"))
total=(pi*100)+(pu*20)+(co*10)
print(total)

16.palindrome or not..if negative print invalid input
n=int(input())
if n>=0:
    s=list(str(n))
    l,r=0,len(s)-1
    while l<r:
        s[l],s[r]=s[r],s[l]
        l+=1
        r-=1
    if n==int(''.join(s)):......................dont use str(s) to convert as string it will show error ...it make as "['1','2','3','4']"
        print("palindrome")
    else:
        print("not palindrome")
else:
    print("invalid input")

17.BUZZ NUMBER..............ENDS WITH 7 OR DIVISIBLE BY 7
def divby7(n):
    if n==0:
        return True
    while n>=7:
        n-=7
    return n==0
n=int(input())
if n%10==7 or divby7(n)==True:
    print("buzz number")
else:
    print("not")

18.You are given an integer array A of length N. In array A, two integers are repeated, meaning two integers appear twice in the array.
You need to transform the array into a valid permutation of integers from 1 to N using the following operation:
In each operation, you can choose any element of the array and increase its value by 1.
Task:
Find and return an integer representing the minimum number of operations required to convert the array into a valid permutation of size N.

n=int(input())
l=list(map(int,input().split()))
l.sort()
used=set()
op=0
for i in range(n):
    while l[i] in used or l[i]>n:..........use while
        l[i]+=1
        op+=1
    else:
        used.add(l[i])
print(op)  

5
[1,2,1,4,5]
o/p:1

19.Jack has been interested in numerology for a while and has learned how to calculate a lucky number for word using the rules below:
Each alphabet in the word has an ASCII value (where ` A' = 65 `` B' = 66 ..., ' Z' = 90, a = 97 etc.).
Each letter in the word is assigned a 1-based index (i.e., the first letter has index 1, the second let 2, and so on).
The lucky number is calculated as follows
1.. Multiply each character's ASCII value by its 1-based index.
2. Include this product in the sum only if either the index or the ASCII value (or both) are odd.

n=int(input())
s=input()
su=0
for i in range(1,n+1):
    p=ord(s[i-1])*i
    if i%2!=0 or (ord(s[i-1]))%2!=0 or (i%2!=0 and (ord(s[i-1]))%2!=0):
        su+=p
print(su)

20. Write a program that checks whether the sum of the first half of an array is less than the sum of the second half. 
If this condition is met, the program should reverse the entire array. Finally, the program should print the resulting array.

l=list(map(int,input().split()))
m=len(l)//2
fir_half=sum(l[:m])
sec_half=sum(l[m:])
if fir_half < sec_half:
    print(l[::-1])
else:
    print(l)

5 6 7 8
o/p:[8,7,6,5]

21.You are given an array of integers containing N elements.
Your task is to find and return an integer value representing the total number of subarrays of size 3 where the sum of the first element and the third element is equal to the second element.

def subarr(l):
    c=0
    for i in range(len(l)-2):
        sub=l[i:i+3]
        if sub[1]==sub[0]+sub[2]:
            c+=1
    return c
l=list(map(int,input().split()))
print(subarr(l))

22.I/P:ABCD
   O/P:266
s=input()
sum=0
for i in s:
    sum+=ord(i)
print(sum)

23.SORT ARRAY BASED ON FREQ HIGH TO LOW IF TWO NUMBER HAVE SAME FREQ ...SMALL ELEMENT FIRST
i/P:[1,1,1,1,2,2,3,4,4,4]
o/p:[1,1,1,1,4,4,4,2,2,3

l=list(map(int,input().split()))
d={}
for i in l:
    d[i]=d.get(i,0)+1
print(sorted(l,key=lambda x:(-d[x],x)))........here based on key the arr is sorted...here it traverse the array and create a tuples of element with its negative freq.

it thinks that in number series higher negative value comes first to lowest.....so it sort the higher negative number's element(high freq element) first...to the lowest

ASCENDING ORDER FREQUENCY

l=list(map(int,input().split()))
d={}
for i in l:
    d[i]=d.get(i,0)+1
print(sorted(l,key=lambda x:(d[x],x)))

WITHOUT LAMBDA FUNCTION
def sort_key(x):
    return (-d[x],x)
l=list(map(int,input().split()))
d={}
for i in l:
    d[i]=d.get(i,0)+1
print(sorted(l,key=sort_key))

24.sort array based oh high freq
i/p:
    2

    5
    5 5 4 6 4
    5
    9 9 9 2 5

o/P:[4 4 5 5 6]
    [9 9 9 2 5]

def sort(l):
    d={}
    for i in l:
        d[i]=d.get(i,0)+1
    return sorted(l,key=lambda x:(-d[x],x)).....rule is sorting based on negative number series
n=int(input())
for i in range(n):
    N=int(input())
    l=list(map(int,input().split()))
    print(*sort(l))

25.INTERSECTION OF TWO ARRAYS

l1=list(map(int,input().split()))
l2=list(map(int,input().split()))
res=[]
for i in l1:
    if i in l2:
        res.append(i)
if res:
    print(*res)
else:
    print('no common id')

26.
1a2b3c4d5
4
alphabets are items....digits are pacaging lines....count how many items are wrapped by packaging liness

s=input()
c=0
for i in range(1,len(s)-1):
    if s[i].isalpha() and s[i-1].isdigit() and s[i+1].isdigit():
        c+=1
print(c)

27.Bulb Factory
n=int(input())
l=list(map(int,input().split()))
C=int(input())
res=[]
le=0
ts=sum([i for i in l])
for i in range(n):
    r=ts-le-l[i]
    if le+r > C:
        res.append(C)
    else:
        res.append(le+r)
    le+=l[i]
print(res)

28...........string expansion based on index a-1,b-2.....
s=input()
d={}
S=set()
for i in range(len(s)):
    if s[i] not in S:
        d[s[i]]=i+1
        S.add(s[i])
res=[]
for i in s:
    res.append(i*d[i])
print('-'.join(res))

29.
i/p:
bad
o/p:2

s=input()
sum=0
for i in range(1,len(s)):
    p=ord(s[i-1])-ord('a')+1
    c=ord(s[i])-ord('a')+1
    sum+=(c-p)
print(sum)

30.
To find distance after S minutes
speed*S*(S+1)/2


COGNIZANT NEXT PDF ADVANCED:
14.
import math
n=int(input())
print(round(math.sqrt(n)))

20.
l=list(map(int,input().split()))
m=0
for i in range(len(l)):
    for j in range(len(l)):
        if l[i]==l[j]:
            res=0
        else:
            res=abs(l[i]-l[j])+abs(i-j)
            m=max(m,res)
print(m)

21.find no of step need to reach last index...starting at index 0 ..if element is pos move forward m steps or move back m steps
l = list(map(int, input().split()))
m = int(input())

i = 0
c = 0
visited = set()

while True:
    if i < 0 or i >= len(l):   # out of bounds
        print(-1)
        break
    if i == len(l) - 1:        # reached last index
        print(c)
        break
    if i in visited:           # loop detected
        print(-1)
        break

    visited.add(i)

    if l[i] > 0:
        i += m
    else:
        i -= m
    c += 1
23.
def maxpass(marks,p=50,m=100):
    b=m-max(marks)
    final=[]
    for i in marks:
        res=i+b
        final.append(min(res,m))
    c=0
    for i in final:
        if i>=p:
            c+=1
    return c
marks=list(map(int,input().split()))
print(maxpass(marks))


yotube:
you are given an array A of size N consisting of integers and you ha to determine a hop vatue H by following the conditions below
You start at index D
From index, the next index in the sequence is i + H
All elements in the selected sequence must be even.
The hop value H must be the smallest possible value that satisfies the above conditions.
Your task is to find and return an integer value representing the small hop value H. If no such hop value exists, return -1.


hop = 1
while hop<n:
    valid = 1
    i = 0
    while i<n:
        if(arr[i]%2==1):
            valid = 0
            break
    if valid ==1:
        return hop
    hop+=1
return -1

